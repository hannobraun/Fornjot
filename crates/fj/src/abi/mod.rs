//! Internal implementation details for the host-guest interface.
//!
//! Note that the vast majority of this module is just providing FFI-safe
//! versions of common `std` types (e.g. `Vec`, `String`, and `Box<dyn Error>`),
//! or FFI-safe trait objects.

mod context;
mod host;
mod metadata;
mod model;
mod wrappers;

use std::any::Any;

pub use self::{
    context::Context,
    host::Host,
    metadata::{ModelMetadata, PluginMetadata},
    model::Model,
    wrappers::{BoxedError, FfiSafeResult, FfiSafeString, FfiSafeVec},
};

#[macro_export]
macro_rules! register_model {
    ($init:expr) => {
        #[no_mangle]
        unsafe extern "C" fn fj_model_init(
            mut host: $crate::abi::Host<'_>,
        ) -> $crate::abi::InitResult {
            let host: &mut dyn $crate::Host = &mut host;

            let result: Result<
                $crate::PluginMetadata,
                Box<dyn std::error::Error + Send + Sync>,
            > = $init(host);

            match result {
                Ok(meta) => $crate::abi::InitResult::Ok(meta.into()),
                Err(e) => $crate::abi::InitResult::Err(e.into()),
            }
        }
    };
}

/// The signature of the function generated by [`register_model`].
///
/// ```rust
/// fj::register_model!(|_| { todo!() });
///
/// const _: fj::abi::InitFunction = fj_model_init;
/// ```
pub type InitFunction = unsafe extern "C" fn(Host<'_>) -> InitResult;
pub type InitResult = FfiSafeResult<PluginMetadata, BoxedError>;
pub type ShapeResult = FfiSafeResult<crate::Shape, BoxedError>;

fn on_panic(payload: Box<dyn Any + Send>) -> ! {
    let msg: &str = if let Some(s) = payload.downcast_ref::<String>() {
        s.as_str()
    } else if let Some(s) = payload.downcast_ref::<&str>() {
        *s
    } else {
        "A panic occurred"
    };

    eprintln!("{msg}");
    // It's not ideal, but panicking across the FFI boundary is UB.
    std::process::abort();
}
