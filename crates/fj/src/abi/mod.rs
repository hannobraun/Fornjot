//! Internal implementation details for the host-guest interface.
//!
//! Note that the vast majority of this module is just providing FFI-safe
//! versions of common `std` types (e.g. `Vec`, `String`, and `Box<dyn Error>`),
//! or FFI-safe trait objects.
//!
/// If the macro generated the wrong code, this doctest would fail.
///
/// ```rust
/// use fj::{abi::INIT_FUNCTION_NAME, PluginMetadata};
///
/// fj::register_model!(|_| {
///     Ok(PluginMetadata::new("Plugin", "1.2.3"))
/// });
///
/// mod x {
///     extern "C" {
///         pub fn fj_model_init(_: *mut fj::abi::Host<'_>) -> fj::abi::InitResult;
///     }
/// }
///
/// // make sure our function has the right signature
/// let func: fj::abi::InitFunction = fj_model_init;
///
/// // We can also make sure the unmangled name is correct by calling it.
///
/// let metadata: fj::PluginMetadata = unsafe {
///     let mut host = Host;
///     let mut host = fj::abi::Host::from(&mut host);
///     x::fj_model_init(&mut host).unwrap().into()
/// };
///
/// assert_eq!(metadata.name, "Plugin");
///
/// struct Host;
/// impl fj::Host for Host {
///     fn register_boxed_model(&mut self, model: Box<dyn fj::Model>) { todo!() }
/// }
/// ```
mod context;
pub mod ffi_safe;
mod host;
mod metadata;
mod model;

use std::any::Any;

pub use self::{
    context::Context,
    host::Host,
    metadata::{ModelMetadata, PluginMetadata},
    model::Model,
};

#[macro_export]
macro_rules! register_model {
    ($init:expr) => {
        #[no_mangle]
        unsafe extern "C" fn fj_model_init(
            mut host: *mut $crate::abi::Host<'_>,
        ) -> $crate::abi::InitResult {
            let host: &mut dyn $crate::Host = &mut *host;

            let result: Result<
                $crate::PluginMetadata,
                Box<dyn std::error::Error + Send + Sync>,
            > = $init(host);

            match result {
                Ok(meta) => $crate::abi::InitResult::Ok(meta.into()),
                Err(e) => $crate::abi::InitResult::Err(e.into()),
            }
        }
    };
}

/// The signature of the function generated by [`register_model`].
///
/// ```rust
/// fj::register_model!(|_| { todo!() });
///
/// const _: fj::abi::InitFunction = fj_model_init;
/// ```
pub type InitFunction = unsafe extern "C" fn(*mut Host<'_>) -> InitResult;
pub type InitResult = ffi_safe::Result<PluginMetadata, ffi_safe::BoxedError>;
pub type ShapeResult = ffi_safe::Result<crate::Shape, ffi_safe::BoxedError>;

/// The name of the function generated by [`register_model`].
///
pub const INIT_FUNCTION_NAME: &str = "fj_model";

fn on_panic(payload: Box<dyn Any + Send>) -> ! {
    let msg: &str =
        if let Some(s) = payload.downcast_ref::<std::string::String>() {
            s.as_str()
        } else if let Some(s) = payload.downcast_ref::<&str>() {
            *s
        } else {
            "A panic occurred"
        };

    eprintln!("{msg}");
    // It's not ideal, but panicking across the FFI boundary is UB.
    std::process::abort();
}
